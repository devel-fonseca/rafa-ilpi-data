import { Injectable, Logger } from '@nestjs/common';
import {
  FinancialCategoryType,
  ContractDocumentStatus,
  FinancialTransactionStatus,
  FinancialTransactionType,
  Prisma,
} from '@prisma/client';
import { endOfMonth, format, parseISO } from 'date-fns';
import { TenantContextService } from '../../prisma/tenant-context.service';
import { DEFAULT_TIMEZONE, getCurrentDateInTz, parseDateOnly } from '../../utils/date.helpers';

type GenerateContractTransactionsInput = {
  competenceMonth?: string;
  userId?: string;
  contractId?: string;
  strictCategory?: boolean;
};

type GenerateContractTransactionsResult = {
  competenceMonth: string;
  generated: number;
  skippedExisting: number;
  skippedNoCategory: number;
  totalEligibleContracts: number;
};

@Injectable()
export class FinancialContractTransactionsService {
  private readonly logger = new Logger(FinancialContractTransactionsService.name);
  private static readonly SOURCE = 'RESIDENT_CONTRACT';
  private static readonly DEFAULT_CATEGORY_NAME = 'Mensalidades de residentes';

  constructor(private readonly tenantContext: TenantContextService) {}

  private toPrismaDate(dateOnly: string): Date {
    return parseISO(`${parseDateOnly(dateOnly)}T12:00:00.000`);
  }

  private resolveCompetenceMonthDateOnly(
    tenantTimezone: string,
    competenceMonth?: string,
  ): string {
    const raw = competenceMonth
      ? parseDateOnly(competenceMonth)
      : getCurrentDateInTz(tenantTimezone || DEFAULT_TIMEZONE);
    const [year, month] = raw.split('-');
    return `${year}-${month}-01`;
  }

  async ensureForCurrentTenant(
    input: GenerateContractTransactionsInput = {},
  ): Promise<GenerateContractTransactionsResult> {
    const tenant = await this.tenantContext.publicClient.tenant.findUnique({
      where: { id: this.tenantContext.tenantId },
      select: { id: true, timezone: true },
    });

    const tenantTimezone = tenant?.timezone || DEFAULT_TIMEZONE;
    const competenceMonthDateOnly = this.resolveCompetenceMonthDateOnly(
      tenantTimezone,
      input.competenceMonth,
    );
    const competenceStart = this.toPrismaDate(competenceMonthDateOnly);
    const competenceEnd = this.toPrismaDate(
      format(endOfMonth(competenceStart), 'yyyy-MM-dd'),
    );

    const incomeCategory = await this.tenantContext.client.financialCategory.findFirst({
      where: {
        tenantId: this.tenantContext.tenantId,
        deletedAt: null,
        isActive: true,
        type: FinancialCategoryType.INCOME,
        name: FinancialContractTransactionsService.DEFAULT_CATEGORY_NAME,
      },
      select: { id: true, name: true },
    });

    if (!incomeCategory) {
      const message =
        'Categoria "Mensalidades de residentes" não encontrada para geração automática de mensalidades.';
      if (input.strictCategory) {
        throw new Error(message);
      }

      this.logger.warn(
        `${message} tenantId=${this.tenantContext.tenantId} competencia=${competenceMonthDateOnly}`,
      );
      return {
        competenceMonth: competenceMonthDateOnly,
        generated: 0,
        skippedExisting: 0,
        skippedNoCategory: 1,
        totalEligibleContracts: 0,
      };
    }

    const contracts = await this.tenantContext.client.residentContract.findMany({
      where: {
        tenantId: this.tenantContext.tenantId,
        deletedAt: null,
        replacedById: null,
        status: { not: ContractDocumentStatus.RESCINDIDO },
        ...(input.contractId ? { id: input.contractId } : {}),
        startDate: { lte: competenceEnd },
        OR: [
          { isIndefinite: true },
          { endDate: { gte: competenceStart } },
        ],
      },
      select: {
        id: true,
        residentId: true,
        contractNumber: true,
        monthlyAmount: true,
        dueDay: true,
        uploadedBy: true,
        resident: { select: { fullName: true } },
      },
    });

    if (contracts.length === 0) {
      return {
        competenceMonth: competenceMonthDateOnly,
        generated: 0,
        skippedExisting: 0,
        skippedNoCategory: 0,
        totalEligibleContracts: 0,
      };
    }

    const existing = await this.tenantContext.client.financialTransaction.findMany({
      where: {
        tenantId: this.tenantContext.tenantId,
        deletedAt: null,
        type: FinancialTransactionType.INCOME,
        isAutoGenerated: true,
        generationSource: FinancialContractTransactionsService.SOURCE,
        residentContractId: { in: contracts.map((contract) => contract.id) },
        competenceMonth: competenceStart,
      },
      select: { residentContractId: true },
    });

    const existingByContract = new Set(
      existing.map((item) => item.residentContractId).filter(Boolean),
    );

    const [year, month] = competenceMonthDateOnly.split('-');
    const competenceLabel = `${month}/${year}`;

    const toCreate: Prisma.FinancialTransactionCreateManyInput[] = contracts
      .filter((contract) => !existingByContract.has(contract.id))
      .map((contract) => {
        const dueDate = this.toPrismaDate(
          `${year}-${month}-${String(contract.dueDay).padStart(2, '0')}`,
        );
        const amount = new Prisma.Decimal(contract.monthlyAmount);

        return {
          tenantId: this.tenantContext.tenantId,
          type: FinancialTransactionType.INCOME,
          categoryId: incomeCategory.id,
          residentId: contract.residentId,
          residentContractId: contract.id,
          isAutoGenerated: true,
          generationSource: FinancialContractTransactionsService.SOURCE,
          amount,
          discountAmount: new Prisma.Decimal(0),
          lateFeeAmount: new Prisma.Decimal(0),
          netAmount: amount,
          currency: 'BRL',
          issueDate: competenceStart,
          dueDate,
          competenceMonth: competenceStart,
          status: FinancialTransactionStatus.PENDING,
          description: `Mensalidade ${competenceLabel} - ${contract.resident.fullName}`,
          notes: contract.contractNumber
            ? `Gerada automaticamente a partir do contrato ${contract.contractNumber}.`
            : 'Gerada automaticamente a partir do contrato do residente.',
          isRecurring: true,
          recurrenceFrequency: 'monthly',
          createdBy: input.userId ?? contract.uploadedBy,
          confirmedBy: null,
        };
      });

    if (toCreate.length > 0) {
      // Tradeoff: usamos createMany + índice único parcial para garantir idempotência
      // mesmo em cenários concorrentes (ex.: múltiplas requisições simultâneas).
      await this.tenantContext.client.financialTransaction.createMany({
        data: toCreate,
        skipDuplicates: true,
      });
    }

    return {
      competenceMonth: competenceMonthDateOnly,
      generated: toCreate.length,
      skippedExisting: contracts.length - toCreate.length,
      skippedNoCategory: 0,
      totalEligibleContracts: contracts.length,
    };
  }

  async ensureCurrentCompetenceBestEffort(
    input: Omit<GenerateContractTransactionsInput, 'strictCategory'> = {},
  ): Promise<void> {
    try {
      await this.ensureForCurrentTenant({ ...input, strictCategory: false });
    } catch (error) {
      this.logger.warn(
        `Falha ao sincronizar mensalidades de contratos para tenant ${this.tenantContext.tenantId}: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }
}
